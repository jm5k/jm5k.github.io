<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dashboard | Linear Clock Lab</title>

    <!-- üîç SEO -->
    <meta
      name="description"
      content="Experimental Dashboard for the Linear Clock Lab ‚Äî arrange clocks, timers, and tools as movable tiles in a minimalist workspace."
    />
    <meta
      name="keywords"
      content="dashboard, linear clock lab, jm5k, time visualization, productivity tools, focus dashboard, custom layout, minimal design"
    />
    <meta name="author" content="jm5k" />
    <meta name="robots" content="index, follow" />
    <link rel="canonical" href="https://linearclocklab.com/dashboard.html" />

    <!-- üîó Social -->
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Dashboard | Linear Clock Lab" />
    <meta
      property="og:description"
      content="Organize your time tools with the Linear Clock Lab dashboard ‚Äî a clean, modular workspace for minimalist focus."
    />
    <meta
      property="og:url"
      content="https://linearclocklab.com/dashboard.html"
    />
    <meta
      property="og:image"
      content="https://linearclocklab.com/profile.png"
    />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Dashboard | Linear Clock Lab" />
    <meta
      name="twitter:description"
      content="Arrange clocks and focus tools in a customizable minimalist dashboard by jm5k."
    />
    <meta
      name="twitter:image"
      content="https://linearclocklab.com/profile.png"
    />

    <!-- üîñ Icons -->
    <link
      rel="icon"
      href="https://linearclocklab.com/profile.png"
      type="image/png"
    />
    <link
      rel="apple-touch-icon"
      href="https://linearclocklab.com/profile.png"
    />

    <style>
      :root {
        --bg: #000;
        --fg: #ccc;
        --muted: #888;
        --accent: #0ff;
        --line: rgba(255, 255, 255, 0.1);
        --tile: #0a0a0a;
        --tile-border: #181818;
        --handle: #222;
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        background: var(--bg);
        color: var(--fg);
        font-family: monospace;
        min-height: 100vh;
      }
      a {
        color: var(--accent);
        text-decoration: none;
      }

      /* Header */
      header {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px 24px;
        border-bottom: 1px solid var(--line);
        background: #050505;
      }
      .returnlink {
        position: absolute;
        left: 24px;
      }
      .returnlink a {
        color: var(--accent);
        font-size: 0.95rem;
      }
      .brand {
        font-size: 1.2rem;
        letter-spacing: 0.5px;
        color: var(--fg);
      }

      /* Toolbar */
      .toolbar {
        display: flex;
        gap: 8px;
        align-items: center;
        justify-content: center;
        padding: 12px 10px 0;
        flex-wrap: wrap;
      }
      .toolbar select,
      .toolbar input,
      .toolbar button,
      .toolbar label {
        background: #0b0b0b;
        color: var(--fg);
        border: 1px solid var(--tile-border);
        padding: 6px 8px;
        border-radius: 6px;
        font-family: monospace;
        font-size: 0.95rem;
      }
      .toolbar label {
        border: none;
        background: transparent;
        padding: 0 2px;
      }
      .toolbar input[type="checkbox"] {
        transform: translateY(1px);
        margin-right: 6px;
      }
      .toolbar button:hover {
        border-color: var(--accent);
      }

      /* Canvas */
      .canvas {
        position: relative;
        width: 98vw;
        max-width: 2000px;
        min-height: 480px;
        margin: 20px auto 60px auto;
        border: 1px solid var(--line);
        border-radius: 10px;
        background: linear-gradient(180deg, #060606, #050505);
        overflow: visible;
      }
      .grid-hint {
        position: absolute;
        inset: 0;
        background-image: linear-gradient(
            to right,
            var(--line) 1px,
            transparent 1px
          ),
          linear-gradient(to bottom, var(--line) 1px, transparent 1px);
        background-size: 80px 100%, 100% 80px;
        pointer-events: none;
        opacity: 0.35;
      }

      /* Tiles */
      .tile {
        position: absolute;
        background: var(--tile);
        border: 1px solid var(--tile-border);
        border-radius: 12px;
        box-shadow: 0 8px 22px rgba(0, 0, 0, 0.35);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        user-select: none;
      }
      .tile:focus-within {
        outline: 1px solid var(--accent);
      }
      .tile-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        padding: 8px 10px;
        background: linear-gradient(180deg, #0f0f0f, #0b0b0b);
        border-bottom: 1px solid var(--tile-border);
        cursor: grab;
      }
      .tile-header.dragging {
        cursor: grabbing;
      }
      .tile-title {
        font-size: 0.95rem;
        color: #ddd;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .tile-actions {
        display: flex;
        gap: 6px;
      }
      .tile-actions button {
        background: var(--handle);
        color: var(--fg);
        border: 1px solid var(--tile-border);
        padding: 4px 8px;
        border-radius: 6px;
        font-family: monospace;
        font-size: 0.85rem;
        cursor: pointer;
      }
      .tile-actions button:hover {
        border-color: var(--accent);
      }
      .tile-content {
        flex: 1;
        background: #000;
        position: relative;
      }
      .tile-content iframe {
        width: 100%;
        height: 100%;
        border: 0;
        position: relative;
        z-index: 1;
      }

      /* Resize handles (always above iframe & shield) */
      .resize-handle {
        position: absolute;
        background: var(--handle);
        opacity: 0.7;
        border: 1px solid var(--tile-border);
        z-index: 3;
      }
      .resize-handle.e {
        right: -6px;
        top: 0;
        width: 12px;
        height: 100%;
        cursor: ew-resize;
      }
      .resize-handle.s {
        bottom: -6px;
        left: 0;
        width: 100%;
        height: 12px;
        cursor: ns-resize;
      }
      .resize-handle.se {
        right: -6px;
        bottom: -6px;
        width: 14px;
        height: 14px;
        cursor: nwse-resize;
        border-radius: 3px;
      }

      /* Iframe shield toggled during drag/resize */
      .shield {
        position: absolute;
        inset: 0;
        background: transparent;
        display: none;
        z-index: 2;
      }
      .shield.active {
        display: block;
      }

      /* Locked visuals (do NOT block tile-actions) */
      .tile.locked .tile-header {
        opacity: 0.6;
        cursor: default;
      }
      .tile.locked .resize-handle {
        opacity: 0.4;
      }

      footer {
        padding: 16px;
        text-align: center;
      }
      .tagline {
        margin: 12px 0 6px 0;
        font-size: 0.95rem;
        color: #ddd;
      }
      .legal {
        font-size: 0.85rem;
        color: var(--muted);
      }
      .thin-line {
        border: none;
        border-top: 1px solid var(--line);
        margin: 24px 0;
      }
    </style>
  </head>
  <body>
    <header>
      <div class="returnlink">
        <a href="index.html">‚Üê Back to Linear Clock Lab</a>
      </div>
      <div class="brand">Experimental Dashboard</div>
    </header>

    <div class="toolbar">
      <label for="tilePreset">Add tile:</label>
      <select id="tilePreset">
        <option value="clock.html|Minimal Clock">Minimal Clock</option>
        <option value="multi-clock.html|Multi-Timezone">
          Multi-Timezone Clock
        </option>
        <option value="clock_presets.html|Clock Presets">Clock Presets</option>
        <option value="focus.html|FocusLine Pomodoro">
          FocusLine Pomodoro
        </option>
        <option value="timer.html|Timer">Timer</option>
        <option value="stopwatch.html|Stopwatch">Stopwatch</option>
      </select>
      <button id="addTile">Add</button>

      <span style="width: 18px"></span>

      <label>Custom URL:</label>
      <input id="customUrl" placeholder="clock.html" size="16" />
      <input id="customTitle" placeholder="Title" size="12" />
      <button id="addCustom">Add Custom</button>

      <span style="width: 18px"></span>

      <label><input type="checkbox" id="lockLayout" /> Lock layout</label>
      <label
        ><input type="checkbox" id="snapToggle" checked /> Snap to grid</label
      >

      <button id="exportLayout" title="Download layout JSON">Export</button>
      <input
        type="file"
        id="importFile"
        accept="application/json"
        style="display: none"
      />
      <button id="importLayout" title="Load layout JSON">Import</button>

      <span style="width: 18px"></span>

      <button id="resetLayout" title="Clear and load defaults">
        Reset Layout
      </button>
    </div>

    <main class="canvas" id="canvas">
      <div class="grid-hint"></div>
    </main>

    <footer>
      <hr class="thin-line" />
      <div class="tagline">Minimal time, Maximum clarity.</div>
      <div class="legal">
        ¬© jm5k 2025 ‚Äî Made by <a href="https://linearclocklab.com/">jm5k</a>
      </div>
    </footer>

    <script>
      (() => {
        const canvas = document.getElementById("canvas");
        const grid = 20;

        const STORAGE_KEY = "lcl_dashboard_v4"; // bumped for clean migration
        const SETTINGS_KEY = "lcl_dashboard_settings_v4";

        let state = loadState() || defaultState();
        let settings = loadSettings() || { locked: false, snap: true };
        let zCounter = 1;

        function defaultState() {
          return {
            tiles: [
              {
                id: uid(),
                title: "Minimal Clock",
                url: "clock.html",
                x: 20,
                y: 20,
                w: 640,
                h: 300,
              },
              {
                id: uid(),
                title: "Multi-Timezone",
                url: "multi-clock.html",
                x: 700,
                y: 20,
                w: 720,
                h: 360,
              },
              {
                id: uid(),
                title: "Clock Presets",
                url: "clock_presets.html",
                x: 20,
                y: 360,
                w: 680,
                h: 420,
              },
              {
                id: uid(),
                title: "FocusLine Pomodoro",
                url: "focus.html",
                x: 720,
                y: 400,
                w: 720,
                h: 420,
              },
              {
                id: uid(),
                title: "Timer",
                url: "timer.html",
                x: 20,
                y: 820,
                w: 520,
                h: 320,
              },
              {
                id: uid(),
                title: "Stopwatch",
                url: "stopwatch.html",
                x: 560,
                y: 820,
                w: 520,
                h: 320,
              },
            ],
          };
        }
        function uid() {
          return "t" + Math.random().toString(36).slice(2, 9);
        }
        function clamp(v, min, max) {
          return Math.min(max, Math.max(min, v));
        }
        function snap(v) {
          return Math.round(v / grid) * grid;
        }
        function maybeSnap(v) {
          return settings.snap ? snap(v) : v;
        }

        function saveState() {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        }
        function loadState() {
          try {
            return JSON.parse(localStorage.getItem(STORAGE_KEY));
          } catch (e) {
            return null;
          }
        }
        function saveSettings() {
          localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        }
        function loadSettings() {
          try {
            return JSON.parse(localStorage.getItem(SETTINGS_KEY));
          } catch (e) {
            return null;
          }
        }

        // ---------- Render ----------
        function initialRender() {
          canvas.querySelectorAll(".tile").forEach((n) => n.remove());
          state.tiles.forEach((model) => canvas.appendChild(buildTile(model)));
          resizeCanvasToContent();
          // reflect locked visuals
          document
            .querySelectorAll(".tile")
            .forEach((t) => t.classList.toggle("locked", settings.locked));
        }

        function buildTile(model) {
          const el = document.createElement("div");
          el.className = "tile";
          el.style.left = model.x + "px";
          el.style.top = model.y + "px";
          el.style.width = model.w + "px";
          el.style.height = model.h + "px";
          el.dataset.id = model.id;
          if (settings.locked) el.classList.add("locked");

          el.innerHTML = `
          <div class="tile-header">
            <div class="tile-title" title="${model.title}">${model.title}</div>
            <div class="tile-actions">
              <button data-action="edit">Edit</button>
              <button data-action="remove">Remove</button>
            </div>
          </div>
          <div class="tile-content">
            <div class="shield"></div>
            <iframe src="${model.url}" loading="lazy"></iframe>
            <div class="resize-handle e"></div>
            <div class="resize-handle s"></div>
            <div class="resize-handle se"></div>
          </div>
        `;

          // Actions (always enabled)
          el.querySelector(".tile-actions").addEventListener("click", (e) => {
            const btn = e.target.closest("button");
            if (!btn) return;
            const id = el.dataset.id;
            if (btn.dataset.action === "remove") {
              state.tiles = state.tiles.filter((x) => x.id !== id);
              saveState();
              el.remove();
              resizeCanvasToContent();
            } else if (btn.dataset.action === "edit") {
              const found = modelById(id);
              if (!found) return;
              const title = prompt("Tile title:", found.title) ?? found.title;
              const url = prompt("Tile URL:", found.url) ?? found.url;
              found.title = (title || found.title).trim();
              found.url = (url || found.url).trim();
              el.querySelector(".tile-title").textContent = found.title;
              el.querySelector("iframe").src = found.url;
              saveState();
            }
          });

          // Drag start (threshold + ignore action buttons)
          el.querySelector(".tile-header").addEventListener(
            "pointerdown",
            (ev) => startDrag(ev, el)
          );

          // Resize
          el.querySelector(".resize-handle.e").addEventListener(
            "pointerdown",
            (e) => startResize(e, el, "e")
          );
          el.querySelector(".resize-handle.s").addEventListener(
            "pointerdown",
            (e) => startResize(e, el, "s")
          );
          el.querySelector(".resize-handle.se").addEventListener(
            "pointerdown",
            (e) => startResize(e, el, "se")
          );

          return el;
        }

        function addTile(model) {
          state.tiles.push(model);
          saveState();
          canvas.appendChild(buildTile(model));
          resizeCanvasToContent();
          document
            .querySelectorAll(".tile")
            .forEach((t) => t.classList.toggle("locked", settings.locked));
        }

        function modelById(id) {
          return state.tiles.find((t) => t.id === id);
        }

        function resizeCanvasToContent() {
          let maxBottom = 0;
          state.tiles.forEach((t) => {
            maxBottom = Math.max(maxBottom, t.y + t.h);
          });
          const padding = 80;
          const newHeight = Math.max(480, maxBottom + padding);
          canvas.style.height = newHeight + "px";
          document.body.style.height = newHeight + 200 + "px";
        }

        // ---------- Drag (with threshold) ----------
        function startDrag(ev, el) {
          if (settings.locked) return; // lock blocks drag/resize only
          if (ev.target.closest(".tile-actions")) return; // allow button clicks

          const id = el.dataset.id;
          const m = modelById(id);
          if (!m) return;

          const header = el.querySelector(".tile-header");
          const shield = el.querySelector(".shield");
          const rectCanvas = canvas.getBoundingClientRect();

          const THRESH = 4;
          const startX = ev.clientX;
          const startY = ev.clientY;
          const baseX = m.x;
          const baseY = m.y;

          let dragging = false;

          function beginDrag(e) {
            dragging = true;
            el.setPointerCapture(e.pointerId);
            el.style.zIndex = (++zCounter).toString();
            header.classList.add("dragging");
            shield.classList.add("active");
          }

          function onMove(e) {
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;

            if (!dragging) {
              if (Math.abs(dx) > THRESH || Math.abs(dy) > THRESH) {
                beginDrag(e);
              } else {
                return; // treat as click
              }
            }

            const newX = clamp(baseX + dx, 0, rectCanvas.width - m.w);
            const newY = clamp(baseY + dy, 0, rectCanvas.height - m.h);

            m.x = newX;
            m.y = newY;
            el.style.left = newX + "px";
            el.style.top = newY + "px";
          }

          function onUp(e) {
            if (dragging) {
              el.releasePointerCapture(e.pointerId);
              header.classList.remove("dragging");
              shield.classList.remove("active");

              m.x = clamp(
                maybeSnap(m.x),
                0,
                Math.max(0, canvas.clientWidth - m.w)
              );
              m.y = clamp(
                maybeSnap(m.y),
                0,
                Math.max(0, canvas.clientHeight - m.h)
              );
              el.style.left = m.x + "px";
              el.style.top = m.y + "px";

              saveState();
              resizeCanvasToContent();
            }
            el.removeEventListener("pointermove", onMove);
            el.removeEventListener("pointerup", onUp);
            el.removeEventListener("pointercancel", onUp);
          }

          // Note: no preventDefault on pointerdown; lets clicks through if not dragging
          el.addEventListener("pointermove", onMove);
          el.addEventListener("pointerup", onUp);
          el.addEventListener("pointercancel", onUp);
        }

        // ---------- Resize ----------
        function startResize(ev, el, edge) {
          if (settings.locked) return;

          const id = el.dataset.id;
          const m = modelById(id);
          if (!m) return;

          ev.preventDefault();
          el.setPointerCapture(ev.pointerId);
          el.style.zIndex = (++zCounter).toString();

          const shield = el.querySelector(".shield");
          shield.classList.add("active");

          const startX = ev.clientX;
          const startY = ev.clientY;
          const baseW = m.w;
          const baseH = m.h;

          function onMove(e) {
            let w = baseW;
            let h = baseH;
            if (edge.includes("e"))
              w = Math.max(240, baseW + (e.clientX - startX));
            if (edge.includes("s"))
              h = Math.max(180, baseH + (e.clientY - startY));

            const rectCanvas = canvas.getBoundingClientRect();
            w = Math.min(w, rectCanvas.width - m.x);
            h = Math.min(h, rectCanvas.height - m.y);

            m.w = w;
            m.h = h;
            el.style.width = w + "px";
            el.style.height = h + "px";
          }

          function onUp(e) {
            el.releasePointerCapture(e.pointerId);
            shield.classList.remove("active");

            m.w = Math.max(240, maybeSnap(m.w));
            m.h = Math.max(180, maybeSnap(m.h));
            el.style.width = m.w + "px";
            el.style.height = m.h + "px";

            saveState();
            resizeCanvasToContent();

            el.removeEventListener("pointermove", onMove);
            el.removeEventListener("pointerup", onUp);
            el.removeEventListener("pointercancel", onUp);
          }

          el.addEventListener("pointermove", onMove);
          el.addEventListener("pointerup", onUp);
          el.addEventListener("pointercancel", onUp);
        }

        // ---------- Toolbar ----------
        document.getElementById("addTile").addEventListener("click", () => {
          const v = document.getElementById("tilePreset").value;
          const [url, title] = v.split("|");
          addTile({
            id: uid(),
            title,
            url,
            x: maybeSnap(40 + Math.random() * 120),
            y: maybeSnap(40 + Math.random() * 120),
            w: 640,
            h: 320,
          });
        });

        document.getElementById("addCustom").addEventListener("click", () => {
          const url = (document.getElementById("customUrl").value || "").trim();
          const title =
            (document.getElementById("customTitle").value || "").trim() ||
            "Custom";
          if (!url) {
            alert('Enter a URL like "clock.html"');
            return;
          }
          addTile({
            id: uid(),
            title,
            url,
            x: maybeSnap(60 + Math.random() * 120),
            y: maybeSnap(60 + Math.random() * 120),
            w: 640,
            h: 360,
          });
        });

        document.getElementById("resetLayout").addEventListener("click", () => {
          if (!confirm("Reset layout to defaults?")) return;
          state = defaultState();
          saveState();
          initialRender();
        });

        // Settings toggles
        const lockCb = document.getElementById("lockLayout");
        const snapCb = document.getElementById("snapToggle");
        lockCb.checked = settings.locked;
        snapCb.checked = settings.snap;

        lockCb.addEventListener("change", () => {
          settings.locked = lockCb.checked;
          saveSettings();
          document
            .querySelectorAll(".tile")
            .forEach((t) => t.classList.toggle("locked", settings.locked));
        });
        snapCb.addEventListener("change", () => {
          settings.snap = snapCb.checked;
          saveSettings();
        });

        // Export / Import
        document
          .getElementById("exportLayout")
          .addEventListener("click", () => {
            const blob = new Blob([JSON.stringify(state, null, 2)], {
              type: "application/json",
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "lcl-dashboard-layout.json";
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
          });

        document
          .getElementById("importLayout")
          .addEventListener("click", () => {
            document.getElementById("importFile").click();
          });

        document
          .getElementById("importFile")
          .addEventListener("change", async (e) => {
            const file = e.target.files?.[0];
            if (!file) return;
            try {
              const txt = await file.text();
              const data = JSON.parse(txt);
              if (!data || !Array.isArray(data.tiles))
                throw new Error("Invalid layout");
              state = data;
              saveState();
              initialRender();
            } catch (err) {
              alert("Import failed: " + err.message);
            } finally {
              e.target.value = "";
            }
          });

        // Kickoff
        initialRender();
      })();
    </script>
  </body>
</html>
