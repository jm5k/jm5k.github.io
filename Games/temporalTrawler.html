<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Temporal Trawler: Idle Fishing</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* --- TECHNOLUST BASE THEME --- */
      :root {
        --bg-deep: #050b1a; /* Dark Navy/Oceanic Purple */
        --clock-track: #1a2a45;
        --time-indicator: #00ffff;
        --prize-color: #ff007f;
        --text-color: #f0f8ff;
        --primary-action: #ffaa00;
        --error-action: #ff5500;
        --glow-filter: drop_shadow(0 0 5px var(--time-indicator));
      }

      /* --- GLOBAL STYLES (Focus on Vertical Compression) --- */
      body {
        background-color: var(--bg-deep);
        color: var(--text-color);
        font-family: "Consolas", "Monospace", monospace;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px;
      }

      /* Hazard Pulse Keyframes */
      @keyframes hazard-pulse-border {
        0% {
          box-shadow: 0 0 20px rgba(255, 85, 0, 0.4);
        }
        50% {
          box-shadow: 0 0 30px rgba(255, 85, 0, 0.9),
            0 0 5px var(--error-action);
        }
        100% {
          box-shadow: 0 0 20px rgba(255, 85, 0, 0.4);
        }
      }

      .game-container {
        width: 100%;
        max-width: 1050px;
        border: 2px solid var(--time-indicator);
        border-radius: 10px;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        padding: 15px;
        background: rgba(0, 0, 0, 0.4);
        display: flex;
        flex-direction: column;
        transition: box-shadow 0.5s ease-in-out;
      }
      /* Class added by JS when hazard is active */
      .hazard-active-border {
        border-color: var(--error-action);
        animation: hazard-pulse-border 1.5s infinite alternate;
      }

      h1 {
        font-size: 1.6rem;
        color: var(--time-indicator);
        text-shadow: 0 0 8px var(--time-indicator);
        margin-bottom: 15px;
      }

      #hazard-display,
      #weather-display {
        font-size: 1rem;
        margin-top: 5px;
        margin-bottom: 5px;
      }

      /* --- THE LINEAR CLOCK --- */
      .clock-wrapper {
        position: relative;
        padding-top: 10px;
        margin-bottom: 25px;
      }

      .time-track {
        height: 15px;
        background-color: var(--clock-track);
        border-radius: 5px;
        position: relative;
        box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
      }

      #time-indicator {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        width: 3px;
        height: calc(100% + 10px);
        background-color: var(--prize-color);
        transform: translateX(-50%);
        box-shadow: 0 0 8px var(--prize-color);
        transition: left 1s linear;
        z-index: 20;
      }

      /* Hazard Zones */
      .hazard-zone {
        position: absolute;
        top: 0;
        bottom: 0;
        background-color: rgba(255, 0, 0, 0.2);
        border-left: 2px dashed var(--error-action);
        border-right: 2px dashed var(--error-action);
        z-index: 15;
        pointer-events: none;
        border-radius: 5px;
      }

      /* --- Ticks and Labels --- */
      .marker-container {
        position: absolute;
        width: 100%;
        height: 40px;
        top: 15px;
        left: 0;
        pointer-events: none;
        z-index: 10;
      }

      .hour-label {
        position: absolute;
        font-size: 0.75rem;
        color: #ccc;
        transform: translateX(-50%);
        margin-top: 15px;
      }

      .tick {
        position: absolute;
        top: 0;
        width: 1px;
        background-color: #666;
        transform: translateX(-50%);
      }

      .tick.hour {
        height: 12px;
        width: 2px;
        background-color: #999;
        pointer-events: auto;
      }

      .tick.quarter {
        height: 8px;
      }

      /* --- PRIZE BOXES (ANIMATED) --- */
      #prize-track {
        position: absolute;
        top: 5px;
        height: 25px;
        width: 100%;
        z-index: 5;
      }

      .prize-box {
        position: absolute;
        width: 18px;
        height: 18px;
        background-color: var(--prize-color);
        border: 2px solid var(--text-color);
        border-radius: 4px;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 10px var(--prize-color);
        cursor: pointer;
        font-size: 1rem;
        line-height: 18px;
        text-align: center;
        transition: transform 0.2s, box-shadow 0.2s, opacity 0.3s,
          background-color 0.3s;
      }

      .prize-box:hover:not(.claimed) {
        transform: translate(-50%, -50%) scale(1.2);
        box-shadow: 0 0 15px var(--prize-color);
      }

      .prize-box.claimed {
        background-color: #444;
        color: #999;
        border-color: #555;
        box-shadow: none;
        pointer-events: none;
        cursor: default;
        transform: translate(-50%, -50%) scale(0.8);
      }

      /* Claim Pulse Animation */
      @keyframes prize-claim-pulse {
        0% {
          transform: translate(-50%, -50%) scale(1);
          box-shadow: 0 0 20px #00ffff;
        }
        50% {
          transform: translate(-50%, -50%) scale(1.5);
          box-shadow: 0 0 40px #00ffff;
        }
        100% {
          transform: translate(-50%, -50%) scale(0.8);
          box-shadow: 0 0 10px #00ffff;
        }
      }
      .prize-box.claim-pulse {
        animation: prize-claim-pulse 0.5s ease-out;
      }

      /* --- RESOURCES DISPLAY (ANIMATED & COMPACT) --- */
      #resource-display {
        @apply flex flex-wrap gap-3 justify-between;
        transition: box-shadow 0.3s ease-out;
        margin-bottom: 5px;
      }
      #resource-display div {
        padding: 6px 10px;
        min-width: 100px;
        border: 1px solid var(--secondary-neon, #00c3ff);
        border-radius: 5px;
        background: rgba(0, 195, 255, 0.1);
        color: var(--text-color);
        box-shadow: inset 0 0 5px rgba(0, 195, 255, 0.5);
        text-align: center;
        transition: transform 0.15s;
      }
      #resource-display .text-2xl {
        font-size: 1.5rem;
      }

      /* Passive Income Pulse Animation */
      @keyframes haul-pulse {
        0% {
          box-shadow: 0 0 20px rgba(0, 255, 127, 0.8),
            inset 0 0 5px rgba(0, 255, 127, 0.5);
        }
        100% {
          box-shadow: 0 0 0 rgba(0, 255, 127, 0),
            inset 0 0 5px rgba(0, 195, 255, 0.5);
        }
      }
      .haul-pulse {
        animation: haul-pulse 0.6s ease-out;
      }

      /* --- LOG BOX (CRITICAL HEIGHT REDUCTION) --- */
      #log-box {
        height: 100px; /* Minimized height */
        overflow-y: scroll;
        padding: 8px;
        border: 1px solid var(--prize-color);
        border-radius: 5px;
        background: rgba(0, 0, 0, 0.6);
        font-size: 0.8rem;
      }

      .log-entry {
        margin-bottom: 5px;
      }
      .log-time {
        color: #999;
        margin-right: 10px;
      }

      /* --- ACTION/UPGRADE PANEL (TWO-COLUMN GRID) --- */
      .action-panel {
        padding: 15px;
        border: 1px dashed var(--primary-action);
        border-radius: 8px;
        margin-top: 15px;

        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
      }

      .action-panel h3 {
        font-size: 1rem;
        margin-bottom: 8px;
      }

      .action-button {
        @apply px-3 py-1.5 text-xs;
      }

      .upgrade-group {
        display: flex;
        flex-direction: column;
      }

      #upgrade-buttons-container {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }

      .upgrade-btn {
        @apply px-3 py-1.5 text-xs w-full;
      }

      .col-span-2 {
        grid-column: span 2 / span 2;
      }
      /* Hidden upgrade descriptions */
      .upgrade-description {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="game-container" class="game-container">
      <h1>THE TEMPORAL TRAWLER: IDLE FISHING</h1>

      <!-- Hazard Alert -->
      <div id="hazard-display" class="text-center font-bold"></div>
      <!-- Weather/Tide Alert -->
      <div id="weather-display" class="text-center font-bold"></div>

      <!-- The Linear Clock Visualization -->
      <div class="clock-wrapper">
        <div class="time-track h-4">
          <!-- Hazard Zones are displayed here -->
          <div id="hazard-zones"></div>
          <!-- The Prize Boxes (RNG Event Triggers) -->
          <div id="prize-track"></div>
        </div>

        <!-- The Current Time Indicator (Moving Line) -->
        <div id="time-indicator" style="left: 0%"></div>

        <!-- Hour Ticks and Labels (00:00 to 24:00) -->
        <div class="marker-container" id="marker-container">
          <!-- JS will populate the ticks and labels here -->
        </div>
      </div>

      <div
        id="current-time-display"
        class="mb-2 text-xl text-center text-yellow-300 font-bold"
        style="text-shadow: 0 0 5px #ffd700"
      >
        Loading Clock...
      </div>

      <!-- Local Storage Status -->
      <div id="save-status">Checking storage...</div>

      <!-- Resources -->
      <h2
        class="text-lg font-bold mb-1 mt-3 text-left"
        style="color: var(--primary-action)"
      >
        FISHING INVENTORY
      </h2>
      <div id="resource-display">
        <!-- Resource counts populated by JS -->
      </div>

      <!-- Action/Upgrade Panel (Two-Column Layout) -->
      <div class="action-panel">
        <!-- Column 1: Actions & Crafting -->
        <div class="action-group">
          <h3 style="color: var(--secondary-neon)">FISHING ACTIONS</h3>
          <div class="flex flex-wrap gap-2">
            <button
              class="action-button"
              onclick="spendResources('cast', 5, 'Bait')"
            >
              üé£ Cast Line (Cost: 5 Bait)
            </button>
            <button
              class="action-button"
              onclick="spendResources('repair', 10, 'Line')"
            >
              üîó Repair Net (Cost: 10 Line)
            </button>
            <button
              class="action-button"
              onclick="spendResources('baitTrap', 3, 'Lures')"
            >
              ü¶Ä Bait Trap (Cost: 3 Lures)
            </button>

            <!-- Sell Catch -->
            <button
              class="action-button"
              onclick="sellCatch()"
              style="border-color: #00ff7f; color: #00ff7f"
            >
              üí∞ Sell Catch (Convert Fish to CatchPoints)
            </button>

            <!-- Crafting Lures -->
            <button
              class="action-button"
              onclick="craftLures()"
              style="border-color: #ffaa00; color: #ffaa00"
            >
              ‚öì Craft Lures (Cost: 5 Bait, 5 Line)
            </button>

            <!-- CHRONO WARP BUTTON REMOVED for Real-Time Only -->
          </div>
        </div>

        <!-- Column 2: Upgrades & Goals -->
        <div class="upgrade-group">
          <h3 style="color: var(--prize-color)">BOAT UPGRADES</h3>

          <div id="upgrade-buttons-container">
            <!-- 1. Engine Upgrade -->
            <div>
              <button
                id="upgrade-engine-btn"
                class="upgrade-btn"
                onclick="upgradeEngine()"
              >
                ‚öôÔ∏è Engine Lvl 0 (Cost: 150 CP)
              </button>
            </div>

            <!-- 2. Net Upgrade -->
            <div>
              <button
                id="upgrade-net-btn"
                class="upgrade-btn"
                onclick="upgradeNet()"
              >
                üï∏Ô∏è Net Lvl 0 (Cost: 200 CP)
              </button>
            </div>

            <!-- 3. Rods Upgrade (Multiplier) -->
            <div>
              <button
                id="upgrade-rods-btn"
                class="upgrade-btn"
                onclick="upgradeRods()"
              >
                ‚¨ÜÔ∏è Rods Lvl 4 (Cost: 100 CP)
              </button>
            </div>

            <!-- 4. Cargo Upgrade -->
            <div>
              <button
                id="upgrade-cargo-btn"
                class="upgrade-btn"
                onclick="upgradeCargoHold()"
              >
                üì¶ Cargo Lvl 0 (Cost: 100 CP)
              </button>
            </div>

            <!-- 5. Crew Hire -->
            <div class="col-span-2 border-t border-gray-700 pt-2 mt-2">
              <button
                id="hire-crew-btn"
                class="upgrade-btn w-full"
                style="border-color: #f7d544; color: #f7d544"
                onclick="hireCrew()"
              >
                üßë‚Äçüíª Hire Crew (Cost: 500 CP)
              </button>
            </div>

            <!-- Marina Access (Long-Term Project: Resource sink) -->
            <button
              id="build-marina-btn"
              class="action-button w-full col-span-2"
              style="border-color: #a0a0ff; color: #a0a0ff"
              onclick="buildMarina()"
            >
              üèóÔ∏è Build Marina Access (Cost: 50 Line, 5 Rods)
            </button>
          </div>
        </div>
      </div>

      <!-- Log -->
      <h2
        class="text-lg font-bold mb-1 mt-3 text-left"
        style="color: var(--primary-action)"
      >
        EVENT LOG
      </h2>
      <div id="log-box"></div>
    </div>

    <script>
      // Key used for localStorage
      const STORAGE_KEY = "temporalTrawlerGameData";

      // --- GAME STATE (Initial Values) ---
      let state = {
        resources: {
          Bait: 50,
          Line: 30,
          Lures: 6,
          Rods: 4, // Multiplier level
          Fish: 10,
        },
        catchPoints: 0,
        prizes: [],
        prizeCount: 7,
        claimRadius: 0.3,
        prizeTypes: ["Bait", "Line", "Lures", "Rods", "Rods", "Rods"],

        // Upgrade Levels and Costs
        engineLevel: 0,
        netLevel: 0,
        cargoLevel: 0,
        crewCount: 0,

        engineCost: 150,
        netCost: 200,
        cargoCost: 100,
        crewCost: 500,

        // Game Constants
        baitCapacity: 100,
        rodUpgradeCost: 100,
        catchPointsDecayRate: 0.005,

        // Environment State
        hazards: [],
        activeHazard: null,
        weather: "Calm Seas",
        weatherChangeIntervalMinutes: 5,
        lastWeatherChange: new Date().getMinutes(),
        marinaBuilt: false,

        // New Save State Variables
        lastSaveTime: null,
        lastTickTime: performance.now(),
      };

      // --- DOM REFERENCES ---
      const dom = {
        gameContainer: document.getElementById("game-container"),
        timeIndicator: document.getElementById("time-indicator"),
        prizeTrack: document.getElementById("prize-track"),
        hazardZones: document.getElementById("hazard-zones"),
        hazardDisplay: document.getElementById("hazard-display"),
        weatherDisplay: document.getElementById("weather-display"),
        buildMarinaBtn: document.getElementById("build-marina-btn"),
        markerContainer: document.getElementById("marker-container"),
        resourceDisplay: document.getElementById("resource-display"),
        logBox: document.getElementById("log-box"),
        currentTimeDisplay: document.getElementById("current-time-display"),
        saveStatus: document.getElementById("save-status"),

        // Upgrade Buttons
        upgradeEngineBtn: document.getElementById("upgrade-engine-btn"),
        upgradeNetBtn: document.getElementById("upgrade-net-btn"),
        upgradeRodsBtn: document.getElementById("upgrade-rods-btn"),
        upgradeCargoBtn: document.getElementById("upgrade-cargo-btn"),
        hireCrewBtn: document.getElementById("hire-crew-btn"),
      };

      // --- LOCAL STORAGE FUNCTIONS ---

      /** Saves the current game state to localStorage. */
      function saveGame() {
        try {
          state.lastSaveTime = new Date().toISOString();
          const stateToSave = JSON.stringify(state);
          localStorage.setItem(STORAGE_KEY, stateToSave);

          dom.saveStatus.textContent = `Progress saved: ${new Date().toLocaleTimeString()}`;
        } catch (e) {
          dom.saveStatus.textContent = `Error saving progress!`;
        }
      }

      /** Loads the game state from localStorage or uses defaults. */
      function loadGame() {
        try {
          const savedState = localStorage.getItem(STORAGE_KEY);
          if (savedState) {
            const loadedState = JSON.parse(savedState);

            Object.assign(state, loadedState);

            state.lastTickTime = performance.now();

            if (state.lastSaveTime) {
              dom.saveStatus.textContent = `Progress loaded from ${new Date(
                state.lastSaveTime
              ).toLocaleTimeString()}`;
            } else {
              dom.saveStatus.textContent = "Progress loaded (no timestamp).";
            }
            return true;
          }
        } catch (e) {
          // If loading fails, use default state
        }
        dom.saveStatus.textContent = "New game started (no previous save).";
        return false;
      }

      // --- TIME CONVERSION UTILITIES ---

      function hourToPercent(hour) {
        return (hour / 24) * 100;
      }

      // --- CORE FUNCTIONS ---

      function initializeClockMarkers() {
        // Clock markers setup (remains the same)
        dom.markerContainer.innerHTML = "";
        const totalMinutesInDay = 24 * 60;

        for (let h = 0; h <= 24; h++) {
          const elapsedMinutes = h * 60;
          const percentPosition = (elapsedMinutes / totalMinutesInDay) * 100;

          const label = document.createElement("div");
          label.className = "hour-label";
          label.textContent = h.toString().padStart(2, "0");
          label.style.left = `${percentPosition.toFixed(2)}%`;
          dom.markerContainer.appendChild(label);

          const hourTick = document.createElement("div");
          hourTick.className = "tick hour";
          hourTick.style.left = `${percentPosition.toFixed(2)}%`;
          dom.markerContainer.appendChild(hourTick);

          if (h < 24) {
            for (let m = 15; m < 60; m += 15) {
              if (m === 0) continue;

              const elapsedM = h * 60 + m;
              const quarterPercent = (elapsedM / totalMinutesInDay) * 100;

              const quarterTick = document.createElement("div");
              quarterTick.className = "tick quarter";
              quarterTick.style.left = `${quarterPercent.toFixed(2)}%`;
              dom.markerContainer.appendChild(quarterTick);
            }
          }
        }
      }

      function generatePrizes() {
        dom.prizeTrack.innerHTML = "";

        if (
          state.prizes.length === 0 ||
          state.prizes.length !== state.prizeCount
        ) {
          state.prizes = [];

          for (let i = 0; i < state.prizeCount; i++) {
            const position = Math.random() * 90 + 5;
            state.prizes.push({
              id: i,
              position: position,
              claimed: false,
              element: null,
            });
          }
          logEvent(
            `Generated ${state.prizeCount} new supply drop locations.`,
            "#ff007f"
          );
        }

        // Rebuild DOM elements for all prizes
        state.prizes.forEach((box) => {
          const prizeEl = document.createElement("div");
          prizeEl.id = `prize-${box.id}`;
          prizeEl.className = `prize-box ${box.claimed ? "claimed" : ""}`;
          prizeEl.textContent = box.claimed ? "‚úÖ" : "üì¶";
          prizeEl.style.left = `${box.position}%`;

          prizeEl.addEventListener("click", () => {
            claimMissedPrize(box);
          });

          dom.prizeTrack.appendChild(prizeEl);
          box.element = prizeEl;
        });
      }

      function scheduleHazards() {
        dom.hazardZones.innerHTML = "";

        if (state.hazards.length === 0 || state.hazards.length !== 3) {
          state.hazards = [];
          const hazardTypes = ["Line Tangle", "Hull Leak", "Heavy Storm"];

          for (let i = 0; i < 3; i++) {
            const startHour = Math.floor(Math.random() * 21) + 1;
            const durationHours = 2;
            const endHour = startHour + durationHours;

            state.hazards.push({
              type: hazardTypes[Math.floor(Math.random() * hazardTypes.length)],
              startTime: startHour,
              endTime: endHour,
              active: false,
              resolved: false,
            });
          }
          logEvent(`Scheduled 3 new hazards for the 24-hour cycle.`, "#ff5500");
        }

        // Rebuild DOM elements for all hazards
        state.hazards.forEach((hazard) => {
          const startP = hourToPercent(hazard.startTime);
          const endP = hourToPercent(hazard.endTime);
          const widthP = endP - startP;

          const hazardEl = document.createElement("div");
          hazardEl.className = "hazard-zone group";
          hazardEl.style.left = `${startP}%`;
          hazardEl.style.width = `${widthP}%`;
          hazardEl.title = `${hazard.type}: ${hazard.startTime}:00 - ${
            hazard.endTime
          }:00${hazard.resolved ? " (Resolved)" : ""}`;

          dom.hazardZones.appendChild(hazardEl);
        });
      }

      function calculateProgress() {
        const now = new Date();
        const hours = now.getHours();
        const minutes = now.getMinutes();
        const seconds = now.getSeconds();
        const totalMinutesInDay = 24 * 60;

        const elapsedMinutes = hours * 60 + minutes + seconds / 60;
        return (elapsedMinutes / totalMinutesInDay) * 100;
      }

      // --- GAME LOOP & TIME LOGIC ---

      let lastCatchMinute = -1;
      let lastHazardCheckTime = Date.now();

      function updateClock() {
        const progress = calculateProgress();
        const now = new Date();
        const deltaTime = (Date.now() - lastHazardCheckTime) / 1000;
        lastHazardCheckTime = Date.now();

        dom.timeIndicator.style.left = `${progress}%`;
        dom.currentTimeDisplay.textContent = `Real-Time Clock: ${now.toLocaleTimeString()}`;

        state.catchPoints += 0.5 * deltaTime;

        catchFishTick(now);
        weatherTick(now);
        checkPrizeClaims(progress);
        checkHazards(now, deltaTime);

        updateResourceDisplay(progress); // Pass progress to update UI logic
      }

      function weatherTick(now) {
        const currentMinute = now.getMinutes();
        const weatherCycle = state.weatherChangeIntervalMinutes;

        if (
          currentMinute % weatherCycle === 0 &&
          currentMinute !== state.lastWeatherChange
        ) {
          state.lastWeatherChange = currentMinute;

          const weatherOptions = [
            { type: "Calm Seas", emoji: "‚òÄÔ∏è", message: "Standard catch rate." },
            { type: "High Tide", emoji: "üåä", message: "Bait gain doubled." },
            {
              type: "Dense Fog",
              emoji: "üå´Ô∏è",
              message: "Bait capacity reduced by 50.",
            },
            {
              type: "Feeding Frenzy",
              emoji: "ü¶à",
              message: "Lure gain doubled.",
            },
          ];

          const newWeather =
            weatherOptions[Math.floor(Math.random() * weatherOptions.length)];
          state.weather = newWeather.type;

          dom.weatherDisplay.innerHTML = `${newWeather.emoji} **Current Tide:** ${newWeather.type} (${newWeather.message})`;
          logEvent(`TIDE CHANGE: ${newWeather.type}.`, "#00ffff");
          saveGame();
        }
      }

      function catchFishTick(now, isWarping = false) {
        const currentMinute = now.getMinutes();

        if (isWarping || currentMinute !== lastCatchMinute) {
          if (!isWarping) lastCatchMinute = currentMinute;

          let baseBait = 1;
          let baseLine = 1;
          let fishCaught = 2 + state.netLevel;

          // Apply Weather Modifiers
          let currentCapacity = state.baitCapacity + state.cargoLevel * 50;
          if (state.weather === "High Tide") {
            baseBait *= 2;
          } else if (state.weather === "Dense Fog") {
            currentCapacity = Math.max(
              state.baitCapacity,
              currentCapacity - 50
            );
          }

          // Apply Long-Term Project Bonus & Multipliers
          const rodMultiplier = Math.max(1, state.resources.Rods);
          const marinaMultiplier = state.marinaBuilt ? 2 : 1;
          const crewMultiplier = state.crewCount > 0 ? 2 : 1;

          const totalMultiplier =
            rodMultiplier * marinaMultiplier * crewMultiplier;

          const baitGained = baseBait * totalMultiplier;
          const lineGained = baseLine * totalMultiplier;
          const totalFishCaught = fishCaught * totalMultiplier;

          // --- Update Resources ---

          // Bait Capacity Limit
          if (state.resources.Bait + baitGained > currentCapacity) {
            const surplus = state.resources.Bait + baitGained - currentCapacity;
            state.resources.Bait = currentCapacity;
            if (!isWarping)
              logEvent(
                `Bait storage full! Lost ${Math.floor(surplus)} Bait.`,
                "#ff5500"
              );
          } else {
            state.resources.Bait += baitGained;
          }

          state.resources.Line += lineGained;
          state.resources.Fish += totalFishCaught;

          if (!isWarping) {
            logEvent(
              `PASSIVE HAUL: +${Math.floor(
                totalFishCaught
              )} Fish, +${Math.floor(baitGained)} Bait, +${Math.floor(
                lineGained
              )} Line. (Total x${Math.floor(totalMultiplier)})`,
              "#00ff7f"
            );

            // Trigger Haul Pulse Animation
            const haulEl = document.getElementById("resource-display");
            if (haulEl) {
              haulEl.classList.add("haul-pulse");
              setTimeout(() => haulEl.classList.remove("haul-pulse"), 600);
            }
          }
        }
      }

      function checkHazards(now, deltaTime) {
        const currentHour = now.getHours() + now.getMinutes() / 60;

        state.activeHazard =
          state.activeHazard ||
          state.hazards.find(
            (hazard) =>
              !hazard.resolved &&
              currentHour >= hazard.startTime &&
              currentHour < hazard.endTime
          );

        if (state.activeHazard && currentHour >= state.activeHazard.endTime) {
          state.activeHazard.resolved = true;
          logEvent(
            `${state.activeHazard.type} window passed unresolved!`,
            "#ff5500"
          );
          state.activeHazard = null;
          saveGame();
        }

        if (state.activeHazard) {
          state.catchPoints = Math.max(
            0,
            state.catchPoints - state.catchPointsDecayRate * deltaTime
          );

          let neededResource = "";
          switch (state.activeHazard.type) {
            case "Line Tangle":
              neededResource = "Lures";
              break;
            case "Hull Leak":
              neededResource = "Line";
              break;
            case "Heavy Storm":
              neededResource = "Rods";
              break;
          }

          dom.hazardDisplay.innerHTML = `‚ö†Ô∏è **${state.activeHazard.type} ACTIVE!** Resolve with: ${neededResource}`;
          // Hazard Visual Alert
          dom.gameContainer.classList.add("hazard-active-border");
        } else {
          dom.hazardDisplay.textContent = "";
          dom.gameContainer.classList.remove("hazard-active-border");
        }
      }

      function checkPrizeClaims(currentProgress) {
        state.prizes.forEach((box) => {
          if (!box.claimed) {
            // Claim prize only if time indicator passed it
            if (currentProgress >= box.position) {
              claimPrize(box, "Real-Time Event");
            }
          }
        });
      }

      // --- PRIZE, RESOURCE, & UPGRADE LOGIC ---

      function claimPrize(box, source, isSilent = false) {
        box.claimed = true;
        if (box.element) {
          box.element.classList.add("claimed", "claim-pulse");
          box.element.textContent = "‚úÖ";
          setTimeout(() => box.element.classList.remove("claim-pulse"), 500); // Remove pulse class
        }

        const prizeIndex = Math.floor(Math.random() * state.prizeTypes.length);
        const prizeType = state.prizeTypes[prizeIndex];

        let quantity = 1;
        if (prizeType === "Bait" || prizeType === "Line") {
          quantity = Math.floor(Math.random() * 3) + 2;
        }

        const currentCapacity = state.baitCapacity + state.cargoLevel * 50;

        if (
          prizeType === "Bait" &&
          state.resources.Bait + quantity > currentCapacity
        ) {
          quantity = Math.max(0, currentCapacity - state.resources.Bait);
          if (quantity === 0) {
            if (!isSilent)
              logEvent(`Bait prize skipped due to storage limit!`, "#ff5500");
            return;
          }
          if (!isSilent)
            logEvent(`Bait prize reduced due to storage limit!`, "#ff5500");
        }

        state.resources[prizeType] =
          (state.resources[prizeType] || 0) + quantity;

        if (!isSilent)
          logEvent(`${source}: +${quantity} ${prizeType}`, "#00ff7f");
        saveGame();
      }

      function claimMissedPrize(box) {
        const currentProgress = calculateProgress();

        // PRIZE BOX FIX: Only allow clicking prizes in the PAST
        if (currentProgress < box.position) {
          logEvent(
            `Cannot claim future prize. Wait for the time indicator to pass it.`,
            "#ff5500"
          );
          return;
        }

        if (box.claimed) return;

        const cost = 5;
        if (state.resources.Bait >= cost) {
          state.resources.Bait -= cost;
          logEvent(`SPENT ${cost} Bait to open missed supply drop.`, "#ff007f");
          claimPrize(box, "Buyback Event");
          updateResourceDisplay(currentProgress);
        } else {
          logEvent(`Cannot buy back prize: Need ${cost} Bait.`, "#ff5500");
        }
      }

      /** Sells all fish for CatchPoints. */
      function sellCatch() {
        if (state.resources.Fish < 1) {
          logEvent(`Net is empty. Nothing to sell!`, "#ff5500");
          return;
        }

        const fishValue = 5;

        // MECHANIC 3: Variable Haul Value
        const maxBonus = 3;
        const rods = state.resources.Rods;

        const randomValue = Math.random() * maxBonus;
        const valueMultiplier =
          1 + Math.min(Math.floor(randomValue * (1 + rods / 5)), maxBonus - 1);

        const totalFish = Math.floor(state.resources.Fish);
        const totalPoints = totalFish * fishValue * valueMultiplier;

        state.catchPoints += totalPoints;
        state.resources.Fish = 0;

        logEvent(
          `SOLD CATCH: ${totalFish} Fish sold for ${totalPoints} CP! (Value x${valueMultiplier})`,
          "#ffaa00"
        );
        updateResourceDisplay(calculateProgress());
        saveGame();
      }

      /** Craft Lures */
      function craftLures() {
        const baitCost = 5;
        const lineCost = 5;
        const output = 1;

        if (
          state.resources.Bait >= baitCost &&
          state.resources.Line >= lineCost
        ) {
          state.resources.Bait -= baitCost;
          state.resources.Line -= lineCost;
          state.resources.Lures += output;
          logEvent(
            `CRAFTED LURES: -${baitCost} Bait, -${lineCost} Line, +${output} Lures.`,
            "#ffaa00"
          );
          saveGame();
        } else {
          logEvent(`Cannot craft: Requires 5 Bait and 5 Line.`, "#ff5500");
        }
        updateResourceDisplay(calculateProgress());
      }

      /**
       * Spends resources on fishing actions OR resolves a hazard.
       */
      function spendResources(action, cost, resourceType) {
        if (state.resources[resourceType] >= cost) {
          // Resolve Hazard Logic
          if (state.activeHazard) {
            const hazard = state.activeHazard;
            let resolved = false;

            if (hazard.type === "Line Tangle" && resourceType === "Lures") {
              resolved = true;
            } else if (hazard.type === "Hull Leak" && resourceType === "Line") {
              resolved = true;
            } else if (
              hazard.type === "Heavy Storm" &&
              resourceType === "Rods"
            ) {
              resolved = true;
            }

            if (resolved) {
              state.activeHazard.resolved = true;
              state.activeHazard = null;
              logEvent(
                `HAZARD RESOLVED! Used ${resourceType}. CatchPoints decay stopped.`,
                "#00ff7f"
              );

              state.resources[resourceType] -= cost;
              updateResourceDisplay(calculateProgress());
              saveGame();
              return;
            }
          }

          const pointsGained = cost * 2 + state.engineLevel;

          // Normal action (increase CatchPoints)
          state.resources[resourceType] -= cost;
          state.catchPoints += pointsGained;

          let message = "";
          switch (action) {
            case "cast":
              message = `Casted line!`;
              break;
            case "repair":
              message = `Net repaired!`;
              break;
            case "baitTrap":
              message = `Trap baited!`;
              break;
          }

          logEvent(`ACTION: ${message} (+${pointsGained} CP)`, "#ffaa00");
          updateResourceDisplay(calculateProgress());
          saveGame();
        } else {
          logEvent(
            `Cannot ${action}: Need ${cost} ${resourceType}.`,
            "#ff5500"
          );
        }
      }

      // --- UPGRADE FUNCTIONS ---

      /** 1. Engine Upgrade */
      function upgradeEngine() {
        const cost = state.engineCost;
        if (state.catchPoints >= cost) {
          state.catchPoints -= cost;
          state.engineLevel += 1;
          state.engineCost = Math.floor(cost * 1.6);
          logEvent(
            `ENGINE UPGRADE! Active CP gain +1. Next cost: ${state.engineCost} CP.`,
            "#00ffff"
          );
          saveGame();
        } else {
          logEvent(`Need ${cost} CatchPoints to upgrade Engine.`, "#ff5500");
        }
        updateResourceDisplay(calculateProgress());
      }

      /** 2. Net Upgrade */
      function upgradeNet() {
        const cost = state.netCost;
        if (state.catchPoints >= cost) {
          state.catchPoints -= cost;
          state.netLevel += 1;
          state.netCost = Math.floor(cost * 1.5);
          logEvent(
            `NET UPGRADE! Base fish caught per minute increased. Next cost: ${state.netCost} CP.`,
            "#00ffff"
          );
          saveGame();
        } else {
          logEvent(`Need ${cost} CatchPoints to upgrade Net.`, "#ff5500");
        }
        updateResourceDisplay(calculateProgress());
      }

      /** 3. Rods Upgrade (Multiplier) */
      function upgradeRods() {
        const cost = state.rodUpgradeCost;
        if (state.catchPoints >= cost) {
          state.catchPoints -= cost;
          state.resources.Rods += 1;
          state.rodUpgradeCost = Math.floor(cost * 1.5);
          logEvent(
            `RODS UPGRADED! Multiplier is now x${state.resources.Rods}. Next cost: ${state.rodUpgradeCost} CP.`,
            "#00ffff"
          );
          saveGame();
        } else {
          logEvent(`Need ${cost} CatchPoints to upgrade Rods.`, "#ff5500");
        }
        updateResourceDisplay(calculateProgress());
      }

      /** 4. Cargo Hold Upgrade */
      function upgradeCargoHold() {
        const cost = state.cargoCost;
        if (state.catchPoints >= cost) {
          state.catchPoints -= cost;
          state.cargoLevel += 1;
          state.cargoCost = Math.floor(cost * 1.4);
          logEvent(
            `CARGO UPGRADE! Bait capacity increased by 50. Next cost: ${state.cargoCost} CP.`,
            "#00ffff"
          );
          saveGame();
        } else {
          logEvent(`Need ${cost} CatchPoints to upgrade Cargo.`, "#ff5500");
        }
        updateResourceDisplay(calculateProgress());
      }

      /** 5. Hire Crew (One-Time, Expensive) */
      function hireCrew() {
        const cost = state.crewCost;
        if (state.crewCount > 0) {
          logEvent(`Crew already hired!`, "#ff5500");
          return;
        }

        if (state.catchPoints >= cost) {
          state.catchPoints -= cost;
          state.crewCount = 1;
          dom.hireCrewBtn.disabled = true;
          dom.hireCrewBtn.textContent = "üßë‚Äçüíª Crew Hired (Multiplier x2)";
          logEvent(
            `CREW HIRED! Passive multiplier doubled permanently!`,
            "#00ffff"
          );
          saveGame();
        } else {
          logEvent(
            `Need ${cost} CatchPoints to hire experienced Crew.`,
            "#ff5500"
          );
        }
        updateResourceDisplay(calculateProgress());
      }

      /** Marina Access (Resource Sink) */
      function buildMarina() {
        const lineCost = 50;
        const rodsCost = 5;

        if (state.marinaBuilt) {
          logEvent(`Marina Access already built!`, "#ff5500");
          return;
        }

        if (
          state.resources.Line >= lineCost &&
          state.resources.Rods >= rodsCost
        ) {
          state.resources.Line -= lineCost;
          state.resources.Rods -= rodsCost;

          state.marinaBuilt = true;
          logEvent(
            `MARINA ACCESS BUILT! Passive Bait/Line/Fish income increased permanently!`,
            "#00ffff"
          );

          dom.buildMarinaBtn.disabled = true;
          dom.buildMarinaBtn.textContent = "üèóÔ∏è Marina Built!";
          saveGame();
        } else {
          logEvent(`Cannot build Marina: Need 50 Line and 5 Rods.`, "#ff5500");
        }
        updateResourceDisplay(calculateProgress());
      }

      function updateResourceDisplay(currentProgress) {
        dom.resourceDisplay.innerHTML = "";

        // Calculate total multiplier for display
        const totalMultiplier =
          state.resources.Rods *
          (state.marinaBuilt ? 2 : 1) *
          (state.crewCount > 0 ? 2 : 1);

        // --- CATCH POINTS ---
        const pointsDiv = document.createElement("div");
        pointsDiv.innerHTML = `<span class="text-xs font-light block text-gray-400">CATCH POINTS</span><span class="text-2xl font-bold">${Math.floor(
          state.catchPoints
        )}</span>`;
        dom.resourceDisplay.appendChild(pointsDiv);

        // --- FISH STOCK ---
        const fishDiv = document.createElement("div");
        fishDiv.innerHTML = `<span class="text-xs font-light block text-gray-400">FISH STOCK</span><span class="text-2xl font-bold">${Math.floor(
          state.resources.Fish
        )}</span>`;
        dom.resourceDisplay.appendChild(fishDiv);

        // --- RESOURCES ---
        const currentCapacity = state.baitCapacity + state.cargoLevel * 50;

        for (const [key, value] of Object.entries(state.resources)) {
          if (key === "Fish" || key === "Rods") continue;

          const div = document.createElement("div");
          let resourceLabel = key.toUpperCase();

          if (key === "Bait") {
            resourceLabel = `BAIT (Cap: ${currentCapacity})`;
          }

          div.innerHTML = `<span class="text-xs font-light block text-gray-400">${resourceLabel}</span><span class="text-2xl font-bold">${Math.floor(
            value
          )}</span>`;
          dom.resourceDisplay.appendChild(div);
        }

        // --- MULTIPLIER ---
        const rodsDiv = document.createElement("div");
        rodsDiv.innerHTML = `<span class="text-xs font-light block text-gray-400">TOTAL MULTIPLIER</span><span class="text-2xl font-bold">x${Math.floor(
          totalMultiplier
        )}</span>`;
        dom.resourceDisplay.appendChild(rodsDiv);

        // --- UPDATE PRIZE BOX CLICKS (Future vs. Past) ---
        state.prizes.forEach((box) => {
          if (box.element && !box.claimed) {
            // Disable clicking for prizes placed in the future
            box.element.style.pointerEvents =
              currentProgress >= box.position ? "auto" : "none";
            box.element.style.opacity =
              currentProgress >= box.position ? "1" : "0.4";
            box.element.style.cursor =
              currentProgress >= box.position ? "pointer" : "default";
          }
        });

        // --- UPGRADE BUTTONS AND DESCRIPTIONS ---

        function updateUpgradeButton(btn, level, cost) {
          const canAfford = state.catchPoints >= cost;

          btn.disabled = !canAfford;
          btn.textContent = `Lvl ${level + 1} (Cost: ${Math.floor(cost)} CP)`;
        }

        // Engine
        updateUpgradeButton(
          dom.upgradeEngineBtn,
          state.engineLevel,
          state.engineCost
        );

        // Net
        updateUpgradeButton(dom.upgradeNetBtn, state.netLevel, state.netCost);

        // Rods (Multiplier)
        updateUpgradeButton(
          dom.upgradeRodsBtn,
          state.resources.Rods,
          state.rodUpgradeCost
        );
        dom.upgradeRodsBtn.textContent = `‚¨ÜÔ∏è Rods Lvl ${
          state.resources.Rods + 1
        } (Cost: ${Math.floor(state.rodUpgradeCost)} CP)`;

        // Cargo Hold
        updateUpgradeButton(
          dom.upgradeCargoBtn,
          state.cargoLevel,
          state.cargoCost
        );

        // Crew Hire
        if (state.crewCount > 0) {
          dom.hireCrewBtn.disabled = true;
          dom.hireCrewBtn.textContent = "üßë‚Äçüíª Crew Hired (Multiplier x2)";
        } else {
          dom.hireCrewBtn.disabled = state.catchPoints < state.crewCost;
        }

        // Marina Button (Kept as is)
        if (state.marinaBuilt) {
          dom.buildMarinaBtn.disabled = true;
          dom.buildMarinaBtn.textContent = "üèóÔ∏è Marina Built!";
        } else if (state.resources.Line < 50 || state.resources.Rods < 5) {
          dom.buildMarinaBtn.disabled = true;
        } else {
          dom.buildMarinaBtn.disabled = false;
        }
      }

      function logEvent(message, color = "#ccc") {
        const now = new Date();
        const timeStr = now.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
        });

        const entry = document.createElement("p");
        entry.className = "log-entry";
        entry.innerHTML = `<span class="log-time">[${timeStr}]</span><span style="color: ${color};">${message}</span>`;

        dom.logBox.prepend(entry);

        while (dom.logBox.children.length > 30) {
          dom.logBox.removeChild(dom.logBox.lastChild);
        }
      }

      // --- GAME START ---

      // 1. Load Game Data (must happen before initialization)
      loadGame();

      // 2. Initialize UI based on loaded state
      initializeClockMarkers();
      generatePrizes();
      scheduleHazards();

      // 3. Reset environment checks based on loaded state
      state.lastWeatherChange =
        new Date().getMinutes() - state.weatherChangeIntervalMinutes;
      weatherTick(new Date());

      updateResourceDisplay(calculateProgress());
      logEvent("Game Loaded. Fishing operations underway.", "#00ffff");

      // 4. Start Loops
      setInterval(updateClock, 1000);

      // Auto-save every 10 seconds
      setInterval(saveGame, 10000);

      // If the game started without a save, perform an initial save
      if (!state.lastSaveTime) {
        saveGame();
      }

      // --- End Game Start ---
    </script>
  </body>
</html>
